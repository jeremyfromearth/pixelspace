// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['utils'], function() {
    var Renderer;
    return Renderer = (function() {
      function Renderer(ctx, id) {
        this.ctx = ctx;
        this.id = id;
        this.translate = __bind(this.translate, this);
        this.text = __bind(this.text, this);
        this.scale = __bind(this.scale, this);
        this.saveTransform = __bind(this.saveTransform, this);
        this.roundedRectangle = __bind(this.roundedRectangle, this);
        this.rotate = __bind(this.rotate, this);
        this.restoreTransform = __bind(this.restoreTransform, this);
        this.rectangle = __bind(this.rectangle, this);
        this.randomColor = __bind(this.randomColor, this);
        this.polygonRing = __bind(this.polygonRing, this);
        this.polygon = __bind(this.polygon, this);
        this.shape = __bind(this.shape, this);
        this.lineStyle = __bind(this.lineStyle, this);
        this.line = __bind(this.line, this);
        this.grid = __bind(this.grid, this);
        this.font = __bind(this.font, this);
        this.color = __bind(this.color, this);
        this.clear = __bind(this.clear, this);
        this.circles = __bind(this.circles, this);
        this.circle = __bind(this.circle, this);
        this.arc = __bind(this.arc, this);
        this.alpha = __bind(this.alpha, this);
        this.width = 0;
        this.height = 0;
        this["static"] = false;
        this.looping = false;
        this.duration = 0;
        this.bg = "#CCCCCC";
        this.stepCount = 0;
        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseIsDown = false;
        this.mouseIsOver = false;
        this.mouseIsDragging = false;
      }

      Renderer.prototype.alpha = function(a) {
        return this.ctx.globalAlpha = a;
      };

      Renderer.prototype.arc = function(x, y, radius, start_angle, end_angle, solid) {
        if (solid == null) {
          solid = true;
        }
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius, start_angle, end_angle);
        if (solid) {
          this.ctx.fill();
        } else {
          this.ctx.stroke();
        }
        return this.ctx.closePath();
      };

      Renderer.prototype.circle = function(x, y, radius, solid) {
        if (solid == null) {
          solid = true;
        }
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius, 0, Math.TWO_PI, false);
        if (solid) {
          this.ctx.fill();
        } else {
          this.ctx.stroke();
        }
        return this.ctx.closePath();
      };

      Renderer.prototype.circles = function(point_list, radius, solid) {
        var p, _i, _len, _results;
        if (solid == null) {
          solid = true;
        }
        if (point_list.length === 0) {
          return;
        }
        _results = [];
        for (_i = 0, _len = point_list.length; _i < _len; _i++) {
          p = point_list[_i];
          _results.push(this.circle(p[0], p[1], radius, solid));
        }
        return _results;
      };

      Renderer.prototype.clear = function() {
        this.ctx.save();
        this.ctx.globalAlpha = 1;
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.color(this.bg);
        this.rectangle(0, 0, this.width, this.height);
        return this.ctx.restore();
      };

      Renderer.prototype.color = function(color) {
        return this.ctx.fillStyle = this.ctx.strokeStyle = color;
      };

      Renderer.prototype.font = function(style) {
        return this.ctx.font = style;
      };

      Renderer.prototype.grid = function(x, y, rows, columns, width, height) {
        var col_width, i, row_height, xpos, ypos, _i, _j, _results;
        row_height = height / rows;
        col_width = width / columns;
        for (i = _i = 0; _i <= rows; i = _i += 1) {
          ypos = (Math.round(y + i * row_height)) + .5;
          this.line(x, ypos, x + width, ypos);
        }
        _results = [];
        for (i = _j = 0; _j <= columns; i = _j += 1) {
          xpos = (Math.round(x + i * col_width)) + .5;
          _results.push(this.line(xpos, y, xpos, y + height));
        }
        return _results;
      };

      Renderer.prototype.line = function(x1, y1, x2, y2) {
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
        return this.ctx.closePath();
      };

      Renderer.prototype.lineStyle = function(line_width, joint_style, cap_style) {
        if (line_width == null) {
          line_width = 1.0;
        }
        if (joint_style == null) {
          joint_style = "round";
        }
        if (cap_style == null) {
          cap_style = "round";
        }
        this.ctx.lineWidth = line_width;
        this.ctx.lineJoin = joint_style;
        return this.ctx.lineCap = cap_style;
      };

      Renderer.prototype.shape = function(point_list, solid, closed) {
        var p, _i, _len;
        if (solid == null) {
          solid = true;
        }
        if (closed == null) {
          closed = true;
        }
        if (point_list.length === 0) {
          return;
        }
        this.ctx.beginPath();
        for (_i = 0, _len = point_list.length; _i < _len; _i++) {
          p = point_list[_i];
          this.ctx.lineTo(p[0], p[1]);
        }
        if (closed) {
          this.ctx.closePath();
          if (solid) {
            return this.ctx.fill();
          } else {
            return this.ctx.stroke();
          }
        } else {
          if (solid) {
            this.ctx.fill();
          } else {
            this.ctx.stroke();
          }
          return this.ctx.closePath();
        }
      };

      Renderer.prototype.polygon = function(x, y, radius, sides, solid) {
        var angle, i, inc, points, _i;
        if (sides == null) {
          sides = 3;
        }
        if (solid == null) {
          solid = true;
        }
        points = [];
        inc = Math.TWO_PI / sides;
        for (i = _i = 0; _i <= sides; i = _i += 1) {
          angle = i * inc;
          points.push([x + Math.cos(angle) * radius, y + Math.sin(angle) * radius]);
        }
        return this.shape(points, solid, true);
      };

      Renderer.prototype.polygonRing = function(x, y, inner_radius, outer_radius, inner_sides, outer_sides, solid) {
        var inc, n, p, _i, _j;
        if (inner_sides == null) {
          inner_sides = 90;
        }
        if (outer_sides == null) {
          outer_sides = 90;
        }
        if (solid == null) {
          solid = true;
        }
        p = {
          x: 0,
          y: 0
        };
        inc = Math.TWO_PI / outer_sides;
        this.ctx.beginPath();
        for (n = _i = 0; _i <= outer_sides; n = _i += 1) {
          p.x = x + Math.cos(inc * n) * outer_radius;
          p.y = y + Math.sin(inc * n) * outer_radius;
          if (n === 0) {
            this.ctx.moveTo(p.x, p.y);
          } else {
            this.ctx.lineTo(p.x, p.y);
          }
        }
        inc = Math.TWO_PI / inner_sides;
        for (n = _j = inner_sides; _j >= 0; n = _j += -1) {
          p.x = x + Math.cos(inc * n) * inner_radius;
          p.y = y + Math.sin(inc * n) * inner_radius;
          if (n === inner_sides) {
            this.ctx.moveTo(p.x, p.y);
          } else {
            this.ctx.lineTo(p.x, p.y);
          }
        }
        if (solid) {
          return this.ctx.fill();
        } else {
          return this.ctx.stroke();
        }
      };

      Renderer.prototype.randomColor = function() {
        return "rgb(" + (Math.floor(Math.random() * 256)).toString() + ',' + (Math.floor(Math.random() * 256)).toString() + ',' + (Math.floor(Math.random() * 256)).toString() + ")";
      };

      Renderer.prototype.rectangle = function(x, y, width, height, solid) {
        if (solid == null) {
          solid = true;
        }
        if (solid) {
          return this.ctx.fillRect(x, y, width, height);
        } else {
          return this.ctx.strokeRect(x, y, width, height);
        }
      };

      Renderer.prototype.restoreTransform = function() {
        return this.ctx.restore();
      };

      Renderer.prototype.rotate = function(theta) {
        return this.ctx.rotate(theta);
      };

      Renderer.prototype.roundedRectangle = function(x, y, width, height, corner_radius, solid) {
        if (solid == null) {
          solid = true;
        }
        this.ctx.beginPath();
        this.ctx.moveTo(x, y + corner_radius);
        this.ctx.lineTo(x, y + height - corner_radius);
        this.ctx.quadraticCurveTo(x, y + height, x + corner_radius, y + height);
        this.ctx.lineTo(x + width - corner_radius, y + height);
        this.ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - corner_radius);
        this.ctx.lineTo(x + width, y + corner_radius);
        this.ctx.quadraticCurveTo(x + width, y, x + width - corner_radius, y);
        this.ctx.lineTo(x + corner_radius, y);
        this.ctx.quadraticCurveTo(x, y, x, y + corner_radius);
        if (solid) {
          return this.ctx.fill();
        } else {
          return this.ctx.stroke();
        }
      };

      Renderer.prototype.saveTransform = function() {
        return this.ctx.save();
      };

      Renderer.prototype.scale = function(x_scale, y_scale) {
        return this.ctx.scale(x_scale, y_scale);
      };

      Renderer.prototype.text = function(x, y, text, solid) {
        if (solid == null) {
          solid = true;
        }
        if (solid) {
          return this.ctx.fillText(text, x, y);
        } else {
          return this.ctx.strokeText(text, x, y);
        }
      };

      Renderer.prototype.translate = function(x, y) {
        return this.ctx.translate(x, y);
      };

      return Renderer;

    })();
  });

}).call(this);
