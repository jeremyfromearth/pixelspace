// Generated by CoffeeScript 1.6.3
(function() {
  var Compiler, Player, Renderer, a, additions, m, _i, _j, _len, _len1, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Compiler = (function() {
    function Compiler(ctx) {
      this.ctx = ctx;
      this.compile = __bind(this.compile, this);
    }

    Compiler.prototype.compile = function(code) {
      var df, error, obj;
      df = null;
      try {
        obj = CoffeeScript["eval"](code, {
          bare: true
        });
        if (obj != null) {
          if (obj.main) {
            df = new obj.main(this.ctx);
          } else {
            this.onNoMainClassError();
            return;
          }
        }
        if (df != null) {
          if (df.init != null) {
            try {
              df.init();
            } catch (_error) {
              error = _error;
              this.onInitError(error);
              return;
            }
          }
          if (df.step != null) {
            try {
              df.step();
            } catch (_error) {
              error = _error;
              this.onStepError(error);
              return;
            }
          }
          if (df.render != null) {
            try {
              df.render();
            } catch (_error) {
              error = _error;
              this.onRenderError(error);
              return;
            }
          }
        }
        obj = null;
        return CoffeeScript["eval"](code, {
          bare: true
        });
      } catch (_error) {
        error = _error;
        return this.onCompilationError(error);
      }
    };

    Compiler.prototype.onNoMainClassError = function() {
      return console.log("onNoMainClassError()");
    };

    Compiler.prototype.onCompilationError = function(error) {
      return console.log("onCompilationError()", error.message);
    };

    Compiler.prototype.onInitError = function(error) {
      return console.log("onInitializationError()");
    };

    Compiler.prototype.onStepError = function(error) {
      return console.log("onStepError()");
    };

    Compiler.prototype.onRenderError = function(error) {
      return console.log("onRenderError()", error.message);
    };

    return Compiler;

  })();

  window.Compiler = Compiler;

  Player = (function() {
    Player.prototype.running = false;

    function Player(canvas) {
      this.canvas = canvas;
      this.stop = __bind(this.stop, this);
      this.step = __bind(this.step, this);
      this.setRenderer = __bind(this.setRenderer, this);
      this.render = __bind(this.render, this);
      this.pause = __bind(this.pause, this);
      this.run = __bind(this.run, this);
      this.loop = __bind(this.loop, this);
      this.getAnimationCallback = __bind(this.getAnimationCallback, this);
      this.frame = 0;
      this.width = this.canvas.clientWidth;
      this.height = this.canvas.clientHeight;
      this.ctx = canvas.getContext("2d");
      this.renderer = null;
      this.loop();
      this.canvas.addEventListener("mousedown", this.onMouseEvent, true);
      this.canvas.addEventListener("mousemove", this.onMouseEvent, true);
      this.canvas.addEventListener("mouseout", this.onMouseEvent, true);
      this.canvas.addEventListener("mouseover", this.onMouseEvent, true);
      this.canvas.addEventListener("mouseup", this.onMouseEvent, true);
    }

    Player.prototype.getAnimationCallback = function() {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || setTimeout(callback, 1000 / 60);
    };

    Player.prototype.loop = function() {
      this.getAnimationCallback()(this.loop);
      if ((this.renderer != null) && this.running && !this.renderer["static"]) {
        this.step();
        return this.render();
      }
    };

    Player.prototype.run = function() {
      return this.running = true;
    };

    Player.prototype.onMouseEvent = function(event) {
      var x, y;
      x = event.offsetX;
      y = event.offsetY;
      if (this.renderer != null) {
        switch (event.type) {
          case "mousedown":
            if (this.renderer.onMouseDown != null) {
              return this.renderer.onMouseDown(x, y);
            }
            break;
          case 'mousemove':
            if (this.renderer.onMouseMove != null) {
              return this.renderer.onMouseMove(x, y);
            }
            break;
          case 'mouseout':
            if (this.renderer.onMouseOut != null) {
              return this.renderer.onMouseOut(x, y);
            }
            break;
          case 'mouseover':
            if (this.renderer.onMouseEnter != null) {
              return this.renderer.onMouseEnter(x, y);
            }
            break;
          case 'mouseup':
            if (this.renderer.onMouseUp != null) {
              return this.renderer.onMouseUp(x, y);
            }
        }
      }
    };

    Player.prototype.pause = function() {
      return this.running = false;
    };

    Player.prototype.render = function() {
      if (this.renderer.clear != null) {
        this.renderer.clear();
      }
      if (this.renderer.render != null) {
        return this.renderer.render();
      }
    };

    Player.prototype.setRenderer = function(newRenderer) {
      this.renderer = newRenderer;
      this.renderer.width = this.canvas.clientWidth;
      return this.renderer.height = this.canvas.clientHeight;
    };

    Player.prototype.step = function() {
      if (this.renderer.looping && this.renderer.duration > 0) {
        if (this.frame > this.renderer.duration) {
          this.frame = 0;
        }
      }
      this.frame++;
      this.renderer.frame = this.frame;
      this.renderer.width = this.canvas.clientWidth;
      this.renderer.height = this.canvas.clientHeight;
      if (this.renderer.step != null) {
        return this.renderer.step();
      }
    };

    Player.prototype.stop = function() {
      this.frame = 0;
      this.running = false;
      this.ctx.clearRect(0, 0, this.width, this.height);
      if (this.renderer != null) {
        if (this.renderer.clear != null) {
          return this.renderer.clear();
        }
      }
    };

    return Player;

  })();

  window.Player = Player;

  _ref = Object.getOwnPropertyNames(Math);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    m = _ref[_i];
    window[m] = Math[m];
  }

  additions = [["TWO_PI", Math.PI * 2]];

  for (_j = 0, _len1 = additions.length; _j < _len1; _j++) {
    a = additions[_j];
    window[a[0]] = a[1];
  }

  Renderer = (function() {
    function Renderer(ctx, id) {
      this.ctx = ctx;
      this.id = id;
      this.translate = __bind(this.translate, this);
      this.text = __bind(this.text, this);
      this.scale = __bind(this.scale, this);
      this.saveTransform = __bind(this.saveTransform, this);
      this.roundedRectangle = __bind(this.roundedRectangle, this);
      this.rotate = __bind(this.rotate, this);
      this.restoreTransform = __bind(this.restoreTransform, this);
      this.rectangle = __bind(this.rectangle, this);
      this.randomColor = __bind(this.randomColor, this);
      this.polygonRing = __bind(this.polygonRing, this);
      this.polygon = __bind(this.polygon, this);
      this.polyline = __bind(this.polyline, this);
      this.points = __bind(this.points, this);
      this.point = __bind(this.point, this);
      this.path = __bind(this.path, this);
      this.lineStyle = __bind(this.lineStyle, this);
      this.line = __bind(this.line, this);
      this.grid = __bind(this.grid, this);
      this.font = __bind(this.font, this);
      this.color = __bind(this.color, this);
      this.clear = __bind(this.clear, this);
      this.arc = __bind(this.arc, this);
      this.frame = 0;
      this.width = 0;
      this.height = 0;
      this["static"] = false;
      this.looping = false;
      this.bg_color = "#CCCCCC";
    }

    Renderer.prototype.arc = function(x, y, radius, start_angle, end_angle, solid) {
      if (solid == null) {
        solid = true;
      }
      this.ctx.beginPath();
      this.ctx.arc(x, y, radius, start_angle, end_angle);
      if (solid) {
        return this.ctx.fill();
      } else {
        return this.ctx.stroke();
      }
    };

    Renderer.prototype.clear = function() {
      this.ctx.clearRect(0, 0, this.width, this.height);
      this.color(this.bg_color);
      return this.rectangle(0, 0, this.width, this.height);
    };

    Renderer.prototype.color = function(color) {
      this.ctx.fillStyle = color;
      return this.ctx.strokeStyle = color;
    };

    Renderer.prototype.font = function(style) {
      return this.ctx.font = style;
    };

    Renderer.prototype.grid = function(x, y, rows, columns, width, height) {
      var col_width, i, row_height, xpos, ypos, _k, _l, _results;
      row_height = height / rows;
      col_width = width / columns;
      for (i = _k = 0; _k <= rows; i = _k += 1) {
        ypos = (round(y + i * row_height)) + .5;
        this.line(x, ypos, x + width, ypos);
      }
      _results = [];
      for (i = _l = 0; _l <= columns; i = _l += 1) {
        xpos = (round(x + i * col_width)) + .5;
        _results.push(this.line(xpos, y, xpos, y + height));
      }
      return _results;
    };

    Renderer.prototype.line = function(x1, y1, x2, y2) {
      this.ctx.beginPath();
      this.ctx.moveTo(x1, y1);
      this.ctx.lineTo(x2, y2);
      return this.ctx.stroke();
    };

    Renderer.prototype.lineStyle = function(line_width, joint_style, cap_style) {
      if (line_width == null) {
        line_width = 1.0;
      }
      if (joint_style == null) {
        joint_style = "round";
      }
      if (cap_style == null) {
        cap_style = "round";
      }
      this.ctx.lineWidth = line_width;
      this.ctx.lineJoin = joint_style;
      return this.ctx.lineCap = cap_style;
    };

    Renderer.prototype.path = function(point_list, solid) {
      var p, _k, _len2;
      if (solid == null) {
        solid = true;
      }
      if (point_list.length === 0) {
        return;
      }
      this.ctx.beginPath();
      this.ctx.moveTo(point_list[0][0], point_list[0][1]);
      for (_k = 0, _len2 = point_list.length; _k < _len2; _k++) {
        p = point_list[_k];
        this.ctx.lineTo(p[0], p[1]);
      }
      this.ctx.closePath();
      if (solid) {
        return this.ctx.fill();
      } else {
        return this.ctx.stroke();
      }
    };

    Renderer.prototype.point = function(x, y, radius, solid) {
      if (solid == null) {
        solid = true;
      }
      this.ctx.beginPath();
      this.ctx.arc(x, y, radius, 0, TWO_PI, false);
      if (solid) {
        return this.ctx.fill();
      } else {
        return this.ctx.stroke();
      }
    };

    Renderer.prototype.points = function(point_list, radius, solid) {
      var p, _k, _len2, _results;
      if (solid == null) {
        solid = true;
      }
      if (point_list.length === 0) {
        return;
      }
      _results = [];
      for (_k = 0, _len2 = point_list.length; _k < _len2; _k++) {
        p = point_list[_k];
        _results.push(this.point(p[0], p[1], radius, solid));
      }
      return _results;
    };

    Renderer.prototype.polyline = function(point_list) {
      var p, _k, _len2;
      if (point_list.length === 0) {
        return;
      }
      this.ctx.beginPath();
      this.ctx.moveTo(point_list[0][0], point_list[0][1]);
      for (_k = 0, _len2 = point_list.length; _k < _len2; _k++) {
        p = point_list[_k];
        this.ctx.lineTo(p[0], p[1]);
      }
      this.ctx.stroke();
      return this.ctx.closePath();
    };

    Renderer.prototype.polygon = function(x, y, radius, sides, solid) {
      var angle, i, inc, points, _k;
      if (sides == null) {
        sides = 3;
      }
      if (solid == null) {
        solid = true;
      }
      points = [];
      inc = TWO_PI / sides;
      for (i = _k = 0; _k <= sides; i = _k += 1) {
        angle = i * inc;
        points.push([x + cos(angle) * radius, y + sin(angle) * radius]);
      }
      return this.path(points, solid);
    };

    Renderer.prototype.polygonRing = function(x, y, inner_radius, outer_radius, inner_sides, outer_sides, solid) {
      var inc, n, p, _k, _l;
      if (inner_sides == null) {
        inner_sides = 90;
      }
      if (outer_sides == null) {
        outer_sides = 90;
      }
      if (solid == null) {
        solid = true;
      }
      p = {
        x: 0,
        y: 0
      };
      inc = TWO_PI / outer_sides;
      this.ctx.beginPath();
      for (n = _k = 0; _k <= outer_sides; n = _k += 1) {
        p.x = x + cos(inc * n) * outer_radius;
        p.y = y + sin(inc * n) * outer_radius;
        if (n === 0) {
          this.ctx.moveTo(p.x, p.y);
        } else {
          this.ctx.lineTo(p.x, p.y);
        }
      }
      inc = TWO_PI / inner_sides;
      for (n = _l = inner_sides; _l >= 0; n = _l += -1) {
        p.x = x + cos(inc * n) * inner_radius;
        p.y = y + sin(inc * n) * inner_radius;
        if (n === inner_sides) {
          this.ctx.moveTo(p.x, p.y);
        } else {
          this.ctx.lineTo(p.x, p.y);
        }
      }
      if (solid) {
        return this.ctx.fill();
      } else {
        return this.ctx.stroke();
      }
    };

    Renderer.prototype.randomColor = function() {
      return "rgb(" + (floor(random() * 256)).toString() + ',' + (floor(random() * 256)).toString() + ',' + (floor(random() * 256)).toString() + ")";
    };

    Renderer.prototype.rectangle = function(x, y, width, height, solid) {
      if (solid == null) {
        solid = true;
      }
      if (solid) {
        return this.ctx.fillRect(x, y, width, height);
      } else {
        return this.ctx.strokeRect(x, y, width, height);
      }
    };

    Renderer.prototype.restoreTransform = function() {
      return this.ctx.restore();
    };

    Renderer.prototype.rotate = function(theta) {
      return this.ctx.rotate(theta);
    };

    Renderer.prototype.roundedRectangle = function(x, y, width, height, corner_radius, solid) {
      if (solid == null) {
        solid = true;
      }
      this.ctx.beginPath();
      this.ctx.moveTo(x, y + corner_radius);
      this.ctx.lineTo(x, y + height - corner_radius);
      this.ctx.quadraticCurveTo(x, y + height, x + corner_radius, y + height);
      this.ctx.lineTo(x + width - corner_radius, y + height);
      this.ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - corner_radius);
      this.ctx.lineTo(x + width, y + corner_radius);
      this.ctx.quadraticCurveTo(x + width, y, x + width - corner_radius, y);
      this.ctx.lineTo(x + corner_radius, y);
      this.ctx.quadraticCurveTo(x, y, x, y + corner_radius);
      if (solid) {
        return this.ctx.fill();
      } else {
        return this.ctx.stroke();
      }
    };

    Renderer.prototype.saveTransform = function() {
      return this.ctx.save();
    };

    Renderer.prototype.scale = function(x_scale, y_scale) {
      return this.ctx.scale(x_scale, y_scale);
    };

    Renderer.prototype.text = function(x, y, text, solid) {
      if (solid == null) {
        solid = true;
      }
      if (solid) {
        return this.ctx.fillText(text, x, y);
      } else {
        return this.ctx.strokeText(text, x, y);
      }
    };

    Renderer.prototype.translate = function(x, y) {
      return this.ctx.translate(x, y);
    };

    return Renderer;

  })();

  window.Renderer = Renderer;

}).call(this);
